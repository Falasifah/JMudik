/**
 * File name      : DispatchListener.java
 * Created on     : 
 * Author         : 
 * 
 * Change Log:
 * Author     Date           Version          Notes
 * =========================================================================
 * adi	 	 28 Aug 2014					Change datestr so that it is compatible
 * 											with java7. 0000-00-00 => 0000-01-01
 * -------------------------------------------------------------------------
 * adi		 28 Aug 2014					Task #1927, tune middleware
 * -------------------------------------------------------------------------
 * adi		 02 Sep 2014					Fix middleware jobs
 * -------------------------------------------------------------------------
 **/

package com.firstwap.middleware.ejb.listener;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.io.UnsupportedEncodingException;
import java.net.Socket;
import java.net.UnknownHostException;
import java.sql.Timestamp;
import java.util.Date;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Resource;
import javax.jms.Connection;
import javax.jms.ConnectionFactory;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.MessageProducer;
import javax.jms.ObjectMessage;
import javax.jms.Session;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.util.NumberUtils;

import com.firstwap.middleware.ejb.entity.SmsDispatcher;
import com.firstwap.middleware.ejb.entity.UserMessageStatus;
import com.firstwap.middleware.ejb.service.DispatcherService;
import com.firstwap.middleware.helper.MessageIdGenerator;
import com.firstwap.middleware.preference.SmsDispatcherPreference;
import com.firstwap.middleware.util.GSM0338Charset;

@Component("dispatchListener")
public class DispatchListener implements MessageListener {

	private static final Logger logger = LoggerFactory.getLogger(DispatchListener.class);
	
	@Resource(mappedName = "java:/ConnectionFactory")
	private ConnectionFactory connectionFactory;

	@Resource(mappedName = "java:/queue/dispatchErrorQueue")
	private Destination destination;
	
	@Autowired
	private DispatcherService dispatcherService;
	
	private SmsDispatcherPreference preference = new SmsDispatcherPreference(); 
	
	private MessageIdGenerator generator = new MessageIdGenerator();
	
	private GSM0338Charset charset = new GSM0338Charset(preference.GSM0338_CHARSET);
	
	public void onMessage(Message message) {
		
		if (message == null) {
			
			return;
		}

		ObjectMessage om = (ObjectMessage) message;

		SmsDispatcher smsdisp = null;
		SmsDispatcher smsdispOri = null;
		
		try {
			
			smsdisp = (SmsDispatcher) om.getObject();
			Date prevRunDate = smsdisp.getRunDate();
			Long smsDispId = smsdisp.getID();
			
			smsdisp = dispatcherService.getSmsDispatcher(smsdisp);
			
			if(smsdisp == null){
				logger.info("This smsDispId {} was deleted", smsDispId);
				return;
			}else if(smsdisp.getRunDate() == null || prevRunDate.compareTo(smsdisp.getRunDate()) != 0){
				logger.info("This smsDispId {} was acquired by another process", smsDispId);
				return;
			}
			
			smsdisp.setServerName(null);
			smsdisp.setRunDate(null);
			logger.debug("releaseUndispatchJob {} {}", preference.SERVER_NAME,smsDispId);
			smsdispOri = (SmsDispatcher) smsdisp.clone();
			
			logger.info("sms id : {}", smsDispId);

			try {
				
				Long.parseLong(smsdisp.getDest().trim());
				
			} catch (NumberFormatException nfe) {
				
				logger.error("Non numeric destination number encountered! The number is {}", smsdisp.getDest());
				errorPush(smsdisp, "AB");
				
				return;
			}

			
			if (!dispatcherService.isInOperatorDialPrefixRange(smsdisp.getDest())) {
				
				logger.error("Cannot find operator for number : {}", smsdisp.getDest());
				errorPush(smsdisp, "AB");
				
				return;
			}
			
			String tranId = generator.generateMessageId((smsdisp.getFlash() == 1 ? true : false));

			Timestamp sendDatetime = new Timestamp(System.currentTimeMillis());
			smsdisp.setTranID(tranId);
			smsdisp.setDateStampSent(sendDatetime);
			smsdisp.setDelvStat("6");
			smsdisp.setStatIntern(2);
			smsdisp.setMsgCntFwap(smsdisp.getMsg().length());

			UserMessageStatus ums = new UserMessageStatus();
			ums.setMessageId(smsdisp.getTranID());
			ums.setUserId(smsdisp.getApiUser());
			ums.setSender(smsdisp.getSrc());
			ums.setDestination(smsdisp.getDest());
			ums.setSendDatetime(smsdisp.getDateStampSent());
			ums.setMessageStatus("");
			String datestr = "0000-01-01 00:00:00";
			Timestamp datetime = Timestamp.valueOf(datestr);
			ums.setStatusDatetime(datetime);
			
			smsdisp = dispatcherService.saveSmsDispacther(smsdisp);
			ums = dispatcherService.saveUserMessageStatus(ums);
			
			logger.debug("persisting smsdisp: " + smsdisp);
			logger.debug("persisting ums: " + ums);

			String messageToQueue = "";
			String response = "";

			String queueHost = "";
			int queuePort = 0;

			if (preference.ALFASENDER_FORMATTING){
				String regex = "^A*[0-9]+";
				Pattern pattern = Pattern.compile(regex);
				Matcher matcher = pattern.matcher(smsdisp.getSrc());
				if (matcher.matches()){
					smsdisp.setSrc(preference.ALFASENDER_ADDITIONALCHAR+smsdisp.getSrc());
				}
			}
			
			boolean isLatin = checkLatin(smsdisp.getMsg());
			if(isLatin){
				messageToQueue = buildMessageLatin(smsdisp);
				
				logger.debug("put message {} to the latin queue:", messageToQueue);
				
				response = put2QueueLatin(messageToQueue);
				queueHost = preference.HOST_QUEUE_LATIN;
				queuePort = preference.PORT_QUEUE_LATIN;
			} else {
				messageToQueue = buildMessageUnicode(smsdisp);
				
				logger.debug("put message {} to the unicode queue:", messageToQueue);
				
				response = put2QueueUnicode(messageToQueue);
				queueHost = preference.HOST_QUEUE_UNICODE;
				queuePort = preference.PORT_QUEUE_UNICODE;
			}

			if (response.indexOf("_SUCC") == -1) {
				
				logger.error("Cannot push the message[{}] to the queue [host={}, port={}]", new Object[] {messageToQueue, queueHost, queuePort});
				smsdispOri.setStatIntern(0);
				sendErrorMessage(smsdispOri);
			}
			
			if ("_SUCC".equals(response.trim())) {
				
				ums.setMessageStatus("140+0+0+0");
				ums.setStatusDatetime(sendDatetime);
				ums = dispatcherService.saveUserMessageStatus(ums);
				
				logger.debug("updated persisting ums when success push to queue : {}", ums);
			}

		} catch (JMSException e) {
			
			logger.error(e.getMessage(), e);
		}
	}
	
	private void sendErrorMessage(SmsDispatcher smsdisp) {

		if (smsdisp == null) {
			
			logger.warn("Attempt to send null object to messaging infrastructure!");
			
			return;
		}

		Connection connection = null;
		Session session = null;
		MessageProducer producer = null;

		try {
			
			connection = connectionFactory.createConnection();
			session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
			connection.start();
			producer = session.createProducer(destination);

			ObjectMessage message = session.createObjectMessage();
			message.setObject(smsdisp);
			producer.send(message);

			session.commit();
			
		} catch (JMSException e) {
			
			logger.error(e.getMessage(), e);
			
		} catch (Exception e) {
			
			logger.error(e.getMessage(), e);
			
		} finally {
			
			try {
				
				if (connection != null) {
					
					connection.stop();
				}
				
				if (producer != null) {
					
					producer.close();
				}
				
				if (session != null) {
					
					session.close();
				}
				
				if (connection != null) {
					
					connection.close();
				}
				
			} catch (JMSException e) {
				
				logger.error(e.getMessage(), e);
			}
		}
	}
	
	private String buildMessageUnicode(SmsDispatcher smsdisp) {
		
		String messageToQueue = "";
		String priorityText = "_PUT3";
		String delimiter = "<TERRY>";
		String alpha = "";
		String alphanumFlag = "";
		String extended = "";
		String message = strToHex(smsdisp.getMsg(), "UTF-16BE");

		messageToQueue = priorityText + " " + smsdisp.getTranID() + delimiter
				+ smsdisp.getDest() + delimiter + checkSenderId(smsdisp.getSrc()) + delimiter
				+ message + extended + alpha + alphanumFlag;

		return messageToQueue;
	}
	
	private String put2QueueUnicode(String messageToQueue) {
		
		String host = preference.HOST_QUEUE_UNICODE;
		int port = preference.PORT_QUEUE_UNICODE;
		
		Socket socket = null;
		PrintStream output = null;
		BufferedReader input = null;
		String response = "";
		
		try {
			
			socket = new Socket(host, port);
			output = new PrintStream(socket.getOutputStream());
			input = new BufferedReader(new InputStreamReader(socket.getInputStream()));
			output.println(messageToQueue);
			output.flush();
			response = input.readLine();
			
			logger.debug("response from queue unicode server : {}", response);
			
		} catch (UnknownHostException e) {
			
			logger.error(e.getMessage(), e);
			
		} catch (IOException e) {
			
			logger.error(e.getMessage(), e);
			
		} finally {
			
			try {
				
				if (output != null) {
					
					output.close();
				}

				if (input != null) {
					
					input.close();
				}

				if (socket != null) {
					
					socket.close();
				}
				
			} catch (IOException e) {
				
				logger.error(e.getMessage(), e);
			}
		}
		
		return response;
	}
	
	@SuppressWarnings("static-access")
	private String buildMessageLatin(SmsDispatcher smsdisp) 
	{		
		String messageToQueue = "";
		String priorityText = "_PUT2";
		String delimiter = "<TERRY>";
		String alpha = "";
		String alphanumFlag = "";
		String extended = "";
		String delimiterexp = "<EXP>";
		String delimiteralpha = "<ALPHA>";
				
		messageToQueue = priorityText + " " + smsdisp.getTranID() + delimiter
				+ smsdisp.getDest() + delimiter + checkSenderId(smsdisp.getSrc()) + delimiter
				+ smsdisp.getMsg() 
				+ (preference.USE_COBRANDER ? delimiter + preference.COBRANDER_NAME + delimiterexp + preference.MOBILETRAX_SERVICEID
							+ delimiterexp + preference.MOBILETRAX_REPLYPATH
							+ delimiteralpha + preference.MOBILETRAX_ALPHAFLAG : "")
				+ extended + alpha + alphanumFlag;
			
		return messageToQueue;
	}
	
	private String put2QueueLatin(String messageToQueue) {
		
		String host = preference.HOST_QUEUE_LATIN;
		int port = preference.PORT_QUEUE_LATIN;
		
		Socket socket = null;
		PrintStream output = null;
		BufferedReader input = null;
		String response = "";
		
		try {
			
			socket = new Socket(host, port);
			output = new PrintStream(socket.getOutputStream());
			input = new BufferedReader(new InputStreamReader(socket.getInputStream()));
			output.println(messageToQueue);
			output.flush();
			response = input.readLine();
			
			logger.debug("response from queue latin server {}", response);
			
		} catch (UnknownHostException e) {
			
			logger.error(e.getMessage(), e);
			
		} catch (IOException e) {
			
			logger.error(e.getMessage(), e);
			
		} finally {
			
			try {
				
				if (output != null) {
					
					output.close();
				}

				if (input != null) {
					
					input.close();
				}

				if (socket != null) {
					
					socket.close();
				}
				
			} catch (IOException e) {
				
				logger.error(e.getMessage(), e);
			}
		}
		return response;
	}
	
	private void errorPush(SmsDispatcher smsdisp, String reason) {

		smsdisp.setStatReason(reason);
		
		if (reason.equals("AA") || reason.equals("AB")) {
			
			smsdisp.setStatIntern(3);
		}
		
		smsdisp.setDelvStat(null);
		dispatcherService.saveSmsDispacther(smsdisp);
	}
	
	private static String checkSenderId(String senderId){
		String senderIdFinal = senderId;
		
		if (senderId.substring(0, 1).equalsIgnoreCase("+")){
			if(senderId.matches(".*[a-zA-Z \\r\\n@£$¥èéùìòÇØøÅå€ÆæßÉ!\"#%&'()*,\\-./:;<=>?¡ÄÖÑÜ§¿äöñüà¤^{}\\\\\\[~\\]|]+.*")){
	           senderIdFinal = " " + senderId;
	        } 
		}
		
		return senderIdFinal;	
	}

	public static String strToHex(String str, String format) {
		StringBuilder output = new StringBuilder();
		String data = "";
		
		try {
			for (final byte b : str.getBytes(format)) {
				output.append(String.format("%1$02X", (b & 0xFF)));
			}
		} catch (UnsupportedEncodingException e) {
			logger.error(e.getMessage(), e);
		}
		
		data = output.toString();
		// (Pattern.quote("005C0026"), "000A") means replace '\&' to '\n'
		return data.replaceAll(Pattern.quote("005C0026"), "000A");
	}
	
	public boolean checkLatin(String text) {
		text = text.trim();
		
	    int latinDigitsCount = 0;

	    for (char symbol : text.toCharArray()) {
	    	if(charset.isGsmSeven(symbol)){
	    		latinDigitsCount++;
	    	}else{
	    		break;
	    	}
	    }
	    return true ? latinDigitsCount == text.length() : false;
	}
}
