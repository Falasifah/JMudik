/**
 * File name      : DispatcherServiceImpl.java
 * Created on     : 
 * Author         : 
 * 
 * Change Log:
 * Author     Date           Version          Notes
 * =========================================================================
 * adi		 28 Aug 2014					Task #1927, tune middleware
 * -------------------------------------------------------------------------
 * adi		 02 Sep 2014					Fix middleware jobs, add LOCK when UPDATE
 * 											Task #2051
 * -------------------------------------------------------------------------
 **/

package com.firstwap.middleware.ejb.service.impl;

import java.math.BigInteger;
import java.util.Calendar;
import java.util.Date;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.firstwap.middleware.ejb.entity.OperatorDialPrefix;
import com.firstwap.middleware.ejb.entity.ReasonMaster;
import com.firstwap.middleware.ejb.entity.SmsDispatcher;
import com.firstwap.middleware.ejb.entity.UserMessageStatus;
import com.firstwap.middleware.ejb.service.DispatcherService;
import com.firstwap.middleware.preference.SmsDispatcherPreference;

@Service
public class DispatcherServiceImpl implements DispatcherService {

	@PersistenceContext(unitName = "SmsDispatcherPU")
	private EntityManager smsdispEM;

	@PersistenceContext(unitName = "SmsApiPU")
	private EntityManager smsapiEM;

	private SmsDispatcherPreference preference = new SmsDispatcherPreference();
	
	private static final Logger logger = LoggerFactory.getLogger(DispatcherServiceImpl.class);
	
	private static final Object UPDATE_LOCK = new Object(); 
	
	@Transactional(value="smsDispatcherTransactionManager", readOnly=false)
	public void releaseUnfinishedDispatchJob() {
		synchronized (UPDATE_LOCK) {
			String hql = "update SmsDispatcher s  set s.serverName = null, s.runDate=null " +
					 "where s.serverName is not null and tranID is null and s.runDate is not null and s.runDate<:threshold ";
		
			Calendar cal=Calendar.getInstance();
			cal.add(Calendar.SECOND,(-1*preference.JOB_THRESHOLD));
			Query query = smsdispEM.createQuery(hql);
			query.setParameter("threshold", cal.getTime());
			query.executeUpdate();
		}
	}
	
	@Transactional(value="smsDispatcherTransactionManager", readOnly=false)
	public void releaseUnfinishedDeliveryJob() {
		synchronized (UPDATE_LOCK) {
			String hql = "update SmsDispatcher s  set s.serverName = null, s.runDate=null " +
					 "where s.serverName is not null and tranID is not null and s.runDate is not null and s.runDate<:threshold ";
		
			Calendar cal=Calendar.getInstance();
			cal.add(Calendar.SECOND,(-1*preference.JOB_THRESHOLD));
			Query query = smsdispEM.createQuery(hql);
			query.setParameter("threshold", cal.getTime());
			query.executeUpdate();
		}
	}	
	
	@Transactional(value="smsDispatcherTransactionManager", readOnly=true)
	public List<SmsDispatcher> getDispatchedMessages() {
		
		String hql = "from SmsDispatcher s where s.tranID is not null and s.statIntern=2 and (s.delvStat = 6 or s.delvStat = 0)";
		
		Query query = smsdispEM.createQuery(hql);
		query.setMaxResults(preference.DELIVERY_LIMIT);
		
		return query.getResultList();
	}

	@Transactional(value="smsDispatcherTransactionManager", readOnly=true)
	public List<SmsDispatcher> getDispatchedMessages(int paramInt, Long lastId) {
		
		String hql = "from SmsDispatcher s where s.serverName=:serverName and s.tranID is not null and s.statIntern=2 and (s.delvStat = 6 or s.delvStat = 0)";

		if(lastId!=null){
			hql += " and id > :lastId";
		}

		Query query = smsdispEM.createQuery(hql).setParameter("serverName", preference.SERVER_NAME);
		if(lastId!=null){
			query.setParameter("lastId", lastId);
		}
		List<SmsDispatcher> list = query.getResultList();
		return list;
	}

	@Transactional(value="smsDispatcherTransactionManager", readOnly=true)
	public List<SmsDispatcher> getUndispatchedMessages() {
		
		String hql = "from SmsDispatcher s where s.serverName=:serverName and s.tranID is null and s.statIntern=0 and (s.scheduleDate is null or s.scheduleDate <= now())";
		
		Query query = smsdispEM.createQuery(hql).setParameter("serverName", preference.SERVER_NAME);
		query.setMaxResults(preference.DISPATCH_LIMIT);
		List<SmsDispatcher> list = query.getResultList();
		return list;
	}
	
	@Transactional(value="smsDispatcherTransactionManager", readOnly=true)
	public List<OperatorDialPrefix> getOperatorDialPrefix(String destination) {
		
		String hql = "from OperatorDialPrefix odp where " + "'" + destination + "' between odp.opDialRangeLower and odp.opDialRangeUpper";
		Query query = smsdispEM.createQuery(hql);
		
		return query.getResultList();
	}
	
	@Transactional(value="smsDispatcherTransactionManager", readOnly=true)
	public boolean isInOperatorDialPrefixRange(String destination) {
		
		String sql = "SELECT COUNT(*) FROM OPERATOR_DIAL_PREFIX WHERE " + destination + " BETWEEN OP_DIAL_RANGE_LOWER AND OP_DIAL_RANGE_UPPER";
		Query query = smsdispEM.createNativeQuery(sql);
		
		int result = 0;
		Object resultCount = null;
		try {
			resultCount = query.getSingleResult();
			if(resultCount!=null){
				result = ((BigInteger)resultCount).intValue();
			}
		} catch (Exception e) {
			logger.error("destination[{}],error parsing operator_dial_prefix_inrange's count to BigInteger [{}]", destination, resultCount, e);
		}
		
		return result > 0;
	}
	
	@Transactional(value="smsApiTransactionManager", readOnly=true)
	public List<UserMessageStatus> getUserMessageStatus(String messageId) {
		
		String hql = "from UserMessageStatus ums where ums.messageId = " + "'" + messageId + "'";
		Query query = smsapiEM.createQuery(hql);
		
		return query.getResultList();
	}
	
	@Transactional(value="smsDispatcherTransactionManager", readOnly=true)
	public ReasonMaster getReasonMaster(String errorCode) {
		
		String hql = "from ReasonMaster rm where rm.errorCode = " + "'" + errorCode + "'";
		Query query = smsdispEM.createQuery(hql);
		
		List<ReasonMaster> list = query.getResultList();
		
		if (list == null || list.isEmpty()) {
			
			return null;
		}
		
		return list.get(0);
	}
	
	@Transactional(value="smsDispatcherTransactionManager", readOnly=false)
	public SmsDispatcher saveSmsDispacther(SmsDispatcher entity) {
		
		return smsdispEM.merge(entity);
	}
	
	@Transactional(value="smsApiTransactionManager", readOnly=false)
	public UserMessageStatus saveUserMessageStatus(UserMessageStatus entity) {
		
		return smsapiEM.merge(entity);
	}
	
	@Transactional(value="smsDispatcherTransactionManager", readOnly=false)
	public void acquireSmsDispatcher(){
		synchronized (UPDATE_LOCK) {
			Query query=smsdispEM.createNativeQuery("UPDATE SMS_DISPATCHER SET SERVER_NAME=:serverName, RUN_DATE=NOW() WHERE TRAN_ID is null and (SERVER_NAME is null or SERVER_NAME = '') and STAT_INTERN=0 and (SCHEDULE_DATE is null or SCHEDULE_DATE<=now()) LIMIT :limit ") 
					.setParameter("serverName",preference.SERVER_NAME)
					.setParameter("limit", preference.DISPATCH_LIMIT);
			
			query.executeUpdate();
		}
	}
	@Transactional(value="smsDispatcherTransactionManager", readOnly=false)
	public void acquireSmsDelivery(Long lastId){
		synchronized (UPDATE_LOCK) {

			String nativeQuery = "UPDATE SMS_DISPATCHER SET SERVER_NAME=:serverName, RUN_DATE=NOW() WHERE TRAN_ID is not null and (SERVER_NAME is null or SERVER_NAME = '') and STAT_INTERN=2 and (DELV_STAT=6 or DELV_STAT=0)";
			if(lastId!=null){
				nativeQuery += " and ID > :lastId";
			}
			nativeQuery += " ORDER BY ID ASC LIMIT :limit";

			Query query=smsdispEM.createNativeQuery(nativeQuery)
					.setParameter("serverName",preference.SERVER_NAME)
					.setParameter("limit", preference.DELIVERY_LIMIT);

			if(lastId!=null){
				query.setParameter("lastId", lastId);
			}

			query.executeUpdate();
		}
	}
	
	@Transactional(value="smsDispatcherTransactionManager", readOnly=true)
	public SmsDispatcher getSmsDispatcher(SmsDispatcher smsDispatcher){
		return smsdispEM.find(SmsDispatcher.class, smsDispatcher.getID());
	}
}
