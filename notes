1.
DispatchSchedulingBean.java
	scheduler jalan..(mungkin pakai cronjob)
	ambil data dari smsdispatcher getUndispatchedMessages() "from SmsDispatcher s where s.serverName=:serverName and s.tranID is null and s.statIntern=0 and (s.scheduleDate is null or s.scheduleDate <= now())"
	setelah dapet, lalu set server_name  ${smsQueuedSuffix:|QUEUED} dan simpan lagi ke SMS_DISPATCHER

	lalu kirim lewat MessageProducer.send 

lalu siapa yg menerima? messageListener!! lebih tepatnya DispatchListener


2. 
DeliverySchedulingBean
	scheduler jalan...acquireSmsDelivery (UPDATE SMS_DISPATCHER SET SERVER_NAME=:serverName, RUN_DATE=NOW() WHERE TRAN_ID is not null and (SERVER_NAME is null or SERVER_NAME = '') and STAT_INTERN=2 and (DELV_STAT=6 or DELV_STAT=0))

	lalu dapatkan getDispatchedMessages(int paramInt, Long lastId)(
		String hql = "from SmsDispatcher s where s.serverName=:serverName and s.tranID is not null and s.statIntern=2 and (s.delvStat = 6 or s.delvStat = 0)";

	setelah dapet, lalu set server_name  ${smsQueuedSuffix:|QUEUED} dan simpan lagi ke SMS_DISPATCHER

	lalu kirim lewat MessageProducer.send 
	
lalu siapa yg menerima? messageListener!! lebih tepatnya DeliveryListener



---------------------
sebenarnya kita punya messageListener yg dipasang di applicationContext.
karena namanya listener, otomatis keduanya akan selalu 'listening' tiap kali ada message yg masuk
method override yg paling sering dipakai 'onMessage()'


DispatchListener
onMessage() {
	//ambil object SMS_DISPATCHER dari objectMessage. 
		//gw masih belum tau kenapa dia bisa menerima objectMessage di method ini (tentu karena di messageListener)
	//update SMS_DISPATCHER.server_name menjadi null
	//nge-set tran_id, datetimesent, delv_stat, stat_intern, msg_cnt_fwap di SMS_DISPATCHER
	//save data ke USER_MESSAGE_STATUS 
	//cek latin atau unicode lalu kirim lewat socket
		jika proses ini sukses, update MESSAGE_STATUS di USER_MESSAGE_STATUS menjadi 140+0+0 dan juga datetime-nya
		
}


DeliveryListener
onMessage() {
	//ambil object SMS_DISPATCHER dari objectMessage. 
	//update SMS_DISPATCHER server_name, run_date menjadi null
	//dapatkan USER_MESSAGE_STATUS berdasarkan sms_dispatcher.tran_id
	// stat_reason
	//update date_stamp_delv, delv_stat, stat_reason di SMS_DISPATCHER
		//stat_reason dihasilkan dari table REASON_MASTER berdasarkan error_code
}


gw masih belum bisa menjawab pertanyaan kenapa SMS_DISPATCHER dan USER_MESSAGE_STATUS ditempatkan
di 2 database yg berbeda. kenapa secara design mereka ditempatkan di 2 schema yg berbeda?
